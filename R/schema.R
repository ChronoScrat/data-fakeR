#' @title Verify Schema
#'
#' @description This function takes a list generated by importing a YAML file and
#'  verifies if it matches the necessary schema.
#'
#' @param list The list object created by the YAML file.
#'
#' @return Logical
#'
#' @examples
#'  \dontrun{
#'   schm <- yaml::read_yaml("schema.yaml")
#'   verify_schema(schm)
#'  }
#'
#' @author Nathanael Rolim \email{Nathanael.Rolim@@gamail.com}
verify_schema <- function(list){

  # First, verify if the schema file begins with a 'table'
  if(("tables" %in% names(list) == FALSE)){
    rlang::abort("No 'tables' list found in the schema.")
  }

  # Verify if the schema is empty
  if(length(list$tables) == 0){
    rlang::abort("There are no tables defined in 'tables'.")
  }

  # Second, we need to verify if:
  ## (a) Each table is named;
  ## (b) Each table has a rows number;
  ## (c) Each table has at least ONE column
  for(i in 1:length(list$tables)){

    # (a)
    if("name" %in% names(list$tables[[i]]) == FALSE){
      rlang::abort(
        glue::glue("Table {i} is not named.")
      )
    }

    # (b)
    if("rows" %in% names(list$tables[[i]]) == FALSE){
      rlang::abort(
        glue::glue("Table {i} has no number of rows.")
      )
    } else if(typeof(list$tables[[i]]$rows) != "integer"){
      rlang::abort(
        glue::glue("Rows in Table {i} is not a number.")
      )
    }

    # (c)
    if("columns" %in% names(list$tables[[i]]) == FALSE){
      rlang::abort(
        glue::glue("Table {i} has no columns.")
      )
    } else if (typeof(list$tables[[i]]$columns) != "list"){
      rlang::abort(
        glue::glue("Columns in Table {i} is empty.")
      )
    }

  }

  # Third, we need to make sure that all columns:
  ## (a) have a name;
  ## (b) have a valid data type
  ## (c) have a column type
  ## (d) and that the column type is configured correctly

  for(i in 1:length(list$tables)){

    for(j in 1:length(list$tables[[i]]$columns)){

      # (a)
      if("name" %in% names(list$tables[[i]]$columns[[j]]) == FALSE){
        rlang::abort(
          glue::glue("Column {j} in Table {i} is not named.")
        )
      }

      # (b) -- Data types are not actually necessary, but R can only infer three types:
      # for the columns: character, integer and double. So even though columns without
      # a data_type should still be valid, they will be read as character.

      ## TODO Add a warning in case a column has no data_type.

      if("data_type" %in% names(list$tables[[i]]$columns[[j]]) == TRUE){

        dt_type <- list$tables[[i]]$columns[[j]]$data_type

        if(dt_type %in% c("Integer","Double","Date","Timestamp","Character","Logical") == FALSE){
          rlang::abort(
            glue::glue("Data type in Column {j} in Table {i} is not supported.")
          )
        }

      }

      # (c)
      if("column_type" %in% names(list$tables[[i]]$columns[[j]]) == FALSE){
        rlang::abort(
          glue::glue("Column {j} in Table {i} has no data_type.")
        )
      }

      # (d)
      clmn_type <- list$tables[[i]]$columns[[j]]$column_type

      if(clmn_type %in% c("Fixed", "Random", "Selection", "Sequential", "Expression") == FALSE){
        rlang::abort(
          glue::glue("Column type in Column {j} in Table {i} is not supported.")
        )
      }

      ## Verify requirements for each column type
      ## TODO Add requirements for 'data_type' as 'Random' and 'Sequential' cannot be 'character', 'Selection' and 'Sequential' cannot be 'logical', and expression can only be 'character'.

      if(clmn_type == "Fixed"){

        if("value" %in% names(list$tables[[i]]$columns[[j]]) == FALSE){
          rlang::abort(
            glue::glue("Column {j} in Table {i} is of type 'Fixed' but has no value.")
          )
        }

      } else if(clmn_type == "Random"){

        if("min" %in% names(list$tables[[i]]$columns[[j]]) == FALSE){
          rlang::abort(
            glue::glue("Column {j} in Table {i} is of type 'Random' but has no min value.")
          )
        }

        if("max" %in% names(list$tables[[i]]$columns[[j]]) == FALSE){
          rlang::abort(
            glue::glue("Column {j} in Table {i} is of type 'Random' but has no max value.")
          )
        }

      #} else if(clmn_type == "Selection"){

      } else if(clmn_type == "Sequential"){

        if("start" %in% names(list$tables[[i]]$columns[[j]]) == FALSE){
          rlang::abort(
            glue::glue("Column {j} in Table {i} is of type 'Sequential' but has no start value.")
          )
        }

        if("step" %in% names(list$tables[[i]]$columns[[j]]) == FALSE){
          rlang::abort(
            glue::glue("Column {j} in Table {i} is of type 'Random' but has no step value.")
          )
        }

      } else if(clmn_type == "Expression"){

        if("expression" %in% names(list$tables[[i]]$columns[[j]]) == FALSE){
          rlang::abort(
            glue::glue("Column {j} in Table {i} is of type 'Expression' but has no expression was provided.")
          )
        }

      }


    }

  }

  return(TRUE)

}





#' @title Import schema
#'
#' @description This function reads and parses the YAML schema file. It also verifies
#'  if the schema is correct and if all arguments are valid.
#'
#' @param file The YAML schema file
#'
#' @importFrom yaml read_yaml
#'
#' @examples
#'  \dontrun{
#'  importParse("_faker.yaml")
#'  }
#'
#' @author Nathanael Rolim \email{Nathanael.Rolim@@gamail.com}
#'
#' @export
import_schema <- function(file = ""){

  # Read the YAML file
  tables <- yaml::read_yaml(file, readLines.warn = FALSE)

  # Run verify_schema on 'tables' to make sure the schema is correct
  if(verify_schema(tables) == TRUE){
    return(TRUE)
  } else{
    return(FALSE)
  }

}


