#' @title Verify Schema
#'
#' @description This function takes a list generated by importing a YAML file and
#'  verifies if it matches the necessary schema.
#'
#' @param list The list object created by the YAML file.
#'
#' @details A function the verify whether a given schema is correct for use with
#'  the `data.fakeR` package. It performs the following checks:
#'  \itemize{
#'   \item 1 - First, it verifies whether a list named `tables` exists. If it does, then it verifies whether this list contains at least one element.
#'   \item 2 - Second, it checks if each table: (a) is named, (b) has a given number of rows, and (c) has at least one column.
#'   \item 3 - Finally, it loops over all columns to determine if they: (a) have a name, (b) have a valid data type (given the column type), and (c) have a valid column type.
#'  }
#'
#' @return Returns `TRUE` if the schema parses correctly, or fails otherwise.
#'
#' @examples
#'  \dontrun{
#'   schm <- yaml::read_yaml("schema.yaml")
#'   verify_schema(schm)
#'  }
#'
#' @author Nathanael Rolim \email{Nathanael.Rolim@@gamail.com}
verify_schema <- function(list){

  # First, verify if the schema file begins with a 'table'
  if(("tables" %in% names(list) == FALSE)){
    rlang::abort("No 'tables' list found in the schema.")
  }

  # Verify if the schema is empty
  if(length(list$tables) == 0){
    rlang::abort("There are no tables defined in 'tables'.")
  }

  # Second, we need to verify if:
  ## (a) Each table is named;
  ## (b) Each table has a rows number;
  ## (c) Each table has at least ONE column
  for(i in 1:length(list$tables)){

    # (a)
    if("name" %in% names(list$tables[[i]]) == FALSE){
      rlang::abort(
        glue::glue("Table {i} is not named.")
      )
    }

    # (b)
    if("rows" %in% names(list$tables[[i]]) == FALSE){
      rlang::abort(
        glue::glue("Table {i} has no number of rows.")
      )
    } else if(typeof(list$tables[[i]]$rows) != "integer"){
      rlang::abort(
        glue::glue("Rows in Table {i} is not a number.")
      )
    }

    # (c)
    if("columns" %in% names(list$tables[[i]]) == FALSE){
      rlang::abort(
        glue::glue("Table {i} has no columns.")
      )
    } else if (typeof(list$tables[[i]]$columns) != "list"){
      rlang::abort(
        glue::glue("Columns in Table {i} is empty.")
      )
    }

  }

  # Third, we need to make sure that all columns:
  ## (a) have a name;
  ## (b) have a valid data type
  ## (c) have a column type
  ## (d) and that the column type is configured correctly

  for(i in 1:length(list$tables)){

    for(j in 1:length(list$tables[[i]]$columns)){

      # (a)
      if("name" %in% names(list$tables[[i]]$columns[[j]]) == FALSE){
        rlang::abort(
          glue::glue("Column {j} in Table {i} is not named.")
        )
      }

      # (b) -- Data types are only necessary for 'Random' and 'Sequential' column types, but users
      # are free to add them to all other types.

      ## TODO Add a warning in case a column has no data_type.

      if("data_type" %in% names(list$tables[[i]]$columns[[j]]) == TRUE){

        dt_type <- list$tables[[i]]$columns[[j]]$data_type

        if(dt_type %in% c("Integer","Double","Date","Timestamp","Character","Logical") == FALSE){
          rlang::abort(
            glue::glue("Data type in Column {j} in Table {i} is not supported.")
          )
        }

      }

      # (c)
      if("column_type" %in% names(list$tables[[i]]$columns[[j]]) == FALSE){
        rlang::abort(
          glue::glue("Column {j} in Table {i} has no data_type.")
        )
      }

      # (d)
      clmn_type <- list$tables[[i]]$columns[[j]]$column_type

      if(clmn_type %in% c("Fixed", "Random", "Selection", "Sequential", "Expression") == FALSE){
        rlang::abort(
          glue::glue("Column type in Column {j} in Table {i} is not supported.")
        )
      }

      ## Verify requirements for each column type
      ## TODO Add requirements for 'data_type' as 'Random' and 'Sequential' cannot be 'character', 'Selection' and 'Sequential' cannot be 'logical', and expression can only be 'character'.

      dt_type <- list$tables[[i]]$columns[[j]]$data_type

      if(clmn_type == "Fixed"){

        if("value" %in% names(list$tables[[i]]$columns[[j]]) == FALSE){
          rlang::abort(
            glue::glue("Column {j} in Table {i} is of type 'Fixed' but has no value.")
          )
        }

      } else if(clmn_type == "Random"){

        if("min" %in% names(list$tables[[i]]$columns[[j]]) == FALSE){
          rlang::abort(
            glue::glue("Column {j} in Table {i} is of type 'Random' but has no min value.")
          )
        }

        if("max" %in% names(list$tables[[i]]$columns[[j]]) == FALSE){
          rlang::abort(
            glue::glue("Column {j} in Table {i} is of type 'Random' but has no max value.")
          )
        }

        if(dt_type == "Character"){
          rlang::abort(
            glue::glue("Data type of Column {j} in Table {i} is not supported for columns of type 'Random'.")
          )
        }

      } else if(clmn_type == "Selection"){

        # We do not make a check for the 'probabilities' option as it is optional.
        # If not supplied by the user, all options will have the same prob.

        if("options" %in% names(list$tables[[i]]$columns[[j]]) == FALSE){
          rlang::abort(
            glue::glue("Column {j} in Table {i} is of type 'Selection' but no values were provided.")
          )
        }


      } else if(clmn_type == "Sequential"){

        if("start" %in% names(list$tables[[i]]$columns[[j]]) == FALSE){
          rlang::abort(
            glue::glue("Column {j} in Table {i} is of type 'Sequential' but has no start value.")
          )
        }

        if("step" %in% names(list$tables[[i]]$columns[[j]]) == FALSE){
          rlang::abort(
            glue::glue("Column {j} in Table {i} is of type 'Random' but has no step value.")
          )
        }

        if(dt_type == "Character" | dt_type == "Logical"){
          rlang::abort(
            glue::glue("Data type of Column {j} in Table {i} is not supported for columns of type 'Random'.")
          )
        }

      } else if(clmn_type == "Expression"){

        if("expression" %in% names(list$tables[[i]]$columns[[j]]) == FALSE){
          rlang::abort(
            glue::glue("Column {j} in Table {i} is of type 'Expression' but has no expression was provided.")
          )
        }

      }


    }

  }

  return(TRUE)

}





#' @title Import schema
#'
#' @description A wrapper function for reading a YAML schema file. It calls `verify_schema` to test whether the
#'  imported schema is correct for use with this package.
#'
#' @param file The YAML schema file
#'
#' @return A list containing the tables schema.
#'
#' @importFrom yaml read_yaml
#'
#' @examples
#'  \dontrun{
#'  importParse("_faker.yaml")
#'  }
#'
#' @author Nathanael Rolim \email{Nathanael.Rolim@@gamail.com}
#'
#' @export
import_schema <- function(file = ""){

  # Read the YAML file
  tables <- yaml::read_yaml(file, readLines.warn = FALSE)

  # Run verify_schema on 'tables' to make sure the schema is correct
  if(verify_schema(tables) == TRUE){
    return(tables)
  }

}


